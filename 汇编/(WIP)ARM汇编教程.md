## 0. 引言
Github: 月と猫 - LunaNeko https://github.com/LunaticLegacy

CC-BY-NC-SA 4.0

本教程可能较为硬核，适合具有一定计算机基础和编程基础的人食用。如果在食用过程中昏厥或口吐白沫，本人概不负责。

本教程为自行总结，可能存在错误。如有错误问题请通过Repo反馈。

本教程使用`GNU ARM`。

## 1. ARM CPU架构：

概述：
- ARM（Advanced RISC Machine）是一种基于精简指令集计算（RISC）原理的CPU架构，最初由Acorn Computers于1983年开发。ARM架构以其低功耗、高性能和可扩展性而闻名，广泛应用于移动设备、嵌入式系统、物联网设备、服务器等领域。
- 上面这个扯淡的可以直接删掉，总之ARM是RISC流派的CPU（但ARM后来恶堕了，接纳了CISC的一些特性。）

### 1.1 寄存器（32位架构下）

#### 1.1.1 32位寄存器概述

32位架构下，ARM共计有37个寄存器，包括31个通用寄存器和6个状态寄存器。

| 寄存器名 | 速记 | 寄存器功能 | 特殊情况 |
| -------- | ------ | --------- | -------- |
| `r{n}` | Register \{n\} | 通用寄存器 | `r13~r15`有特殊用途。 |
| `r13` | Stack Pointer | 栈指针，指向当前栈顶。相当于`rsp` |
| `r14` | Link Register | 链接指针，储存在**调用**后的返回地址 |
| `r15` | Program Counter | 程序计数器，下一条指令的地址 | - |
| `CPSR` | Current Program Status Register | 当前程序状态寄存器，包含条件标志、控制位等 | 包含N、Z、C、V等条件标志位 |
| `SPSR` | Saved Program Status Register | 保存的程序状态寄存器，用于异常模式 | 在异常发生时保存CPSR的值 |

- `n in range(1, 1+15)`。

#### 1.1.2 影子寄存器 / 银行寄存器（Bank Register）

| 寄存器 | 常见共享 | 特殊/模式专用 |
| ------ | ------ | ------ |
| r0–r7 | 共用 | — |
| r8–r12 | 共用（除FIQ） | 在FIQ模式下，有单独 r8_fiq–r12_fiq |
| r13 (SP) | 共用/覆盖 | 各模式有各自 r13_xxx |
| r14 (LR) | 共用/覆盖 | 各模式有各自 r14_xxx |
| r15 (PC) | 全局 | — |
| CPSR | 全局 | —  |
| SPSR (模式专用) | — | SPSR_irq, SPSR_fiq, SPSR_svc, … |

### 1.2 寄存器（64位架构下）

ARM的64位架构称为AArch64，使用A64指令集。与32位架构相比，它提供了更多的寄存器和更大的寻址空间。

#### 1.2.1 64位寄存器概述

AArch64提供了31个64位通用寄存器，命名为X0-X30。每个64位寄存器还有一个对应的32位视图，命名为W0-W30。

| 寄存器名 | 速记 | 寄存器功能 | 特殊情况 |
| -------- | ------ | --------- | -------- |
| `X{n}`/`W{n}` | Register \{n\} | 64位/32位通用寄存器 | X30用作链接寄存器 |
| `X29`/`W29` | Frame Pointer | 帧指针 | 相当于x86的rbp |
| `X30`/`W30` | Link Register | 链接寄存器，存储函数返回地址 | 相当于x86的rip（间接） |
| `SP` | Stack Pointer | 栈指针 | 专用寄存器，不是通用寄存器 |
| `PC` | Program Counter | 程序计数器 | 不能直接访问 |
| `CPSR` | Current Program Status Register | 当前程序状态寄存器 | 包含N、Z、C、V等条件标志位 |

- `n in range(0, 0+30)`

与32位版本不同，AArch64没有影子寄存器。异常处理通过软件方式保存和恢复寄存器状态，而不是使用硬件分组寄存器。

#### 1.2.2 64位架构特点

1. **寄存器数量增加**：从16个增加到31个通用寄存器，减少了对栈的依赖
2. **寄存器宽度增加**：从32位扩展到64位
3. **PC寄存器不可直接访问**：提高了安全性和代码健壮性
4. **SP为专用寄存器**：不能作为通用寄存器使用
5. **统一寄存器模型**：没有影子寄存器，异常处理方式不同

## 2. GNU ASM教程

### 2.1 内存IO

| 指令 | 速记 | 用途 | 示例代码 | 示例释义 | 架构版本 |
| ------ | ------ | ---- | ------ | ----- | -------- |
| `LDR`  | LoaD Register| 从内存读取数据到寄存器 | `LDR R1, [R0, #0x12]`| 将地址 `R0+0x12` 处的32位数据读出，保存到 `R1`。 | ARMv4+ (A32)，ARMv8-A (A64) |
| `STR`  | STore Register  | 将寄存器数据写入内存 | `STR R0, [R1, #8]` | 将寄存器 `R0` 的值存储到地址 `R1+8` 处。| ARMv4+ (A32)，ARMv8-A (A64) |
| `PUSH` | Push | 将寄存器列表推入栈（存储到内存） | `PUSH {R4, R5}`  | 将 `R4` 和 `R5` 的值压入栈顶（等价于 `STMDB SP!, {R4,R5}`）。 | ARMv4+ (A32) |
| `POP` | Pop | 将栈顶数据弹出到寄存器列表 | `POP {R4, R5}` | 从栈顶加载数据到 `R4` 和 `R5`（等价于 `LDMIA SP!, {R4,R5}`）。| ARMv4+ (A32) |
| `STP` | STore Pair | 将两个寄存器的值存储到连续内存位置（常用于栈）  | `STP X29, X30, [SP, #-16]!` | 将 `X29` 和 `X30` 的值存入栈顶（SP 减少 16 字节）。 | ARMv8-A (A64)              |
| `LDP` | LoaD Pair | 从连续内存位置加载两个寄存器（常用于栈） | `LDP X29, X30, [SP], #16`   | 从栈顶加载值到 `X29` 和 `X30`，并将 SP 增加 16 字节。 | ARMv8-A (A64)|
| `ADR` | Address   | 生成标签地址的低位并载入寄存器（PC 相对）| `ADR R0, label` | 计算标签 `label` 的地址（PC+offset），加载到 `R0`。| ARMv6T2+ (A32) |
| `ADRP` | Address Page | 生成标签所在4KB页基地址并载入寄存器（A64） | `ADRP X0, label` | 计算标签 `label` 所在4KB页的基地址，加载到 `X0`。| ARMv8-A (A64) |


### 2.2 算术类
| 指令 | 速记 | 用途 | 示例代码 | 示例释义 | 架构版本 |
| ------ | ----- | ----- | ---- | ----- | ----- |
| `ADD`  | Add | 两寄存器或寄存器与立即数相加 | `ADD R0, R1, R2` | 将 `R1 + R2` 的结果加到 `R0`（不更新标志位）。 | ARMv4+           |
| `ADC`  | Add with inC | 带进位加 `Rn + Rm + C` | `ADC R0, R1, R2` | 将 `R1 + R2 + Carry` 的结果加到 `R0`（用于多字算术）。 | ARMv4+ |
| `SUB`  | Subtract | 两寄存器或寄存器与立即数相减 | `SUB R0, R1, R2` | 将 `R1 - R2` 的结果存入 `R0`（不更新标志位）。 | ARMv4+ |
| `SBC`  | Subtract with deC | 带借位减 `Rn - Rm - ¬C`    | `SBC R0, R1, R2` | 将 `R1 - R2 - (NOT Carry)` 的结果存入 `R0`（用于多字算术）。        | ARMv4+           |
| `QADD` | Q Add | 两寄存器相加结果饱和（32位范围）      | `QADD R0, R1, R2` | 将 `R1 + R2` 做饱和加法，结果限于32位带符号范围（溢出时设Q标志）。 | ARMv6+ (ARMv7-A) |
| `QSUB` |  Q Subtract  | 两寄存器相减结果饱和（32位范围） | `QSUB R0, R1, R2` | 将 `R1 - R2` 做饱和减法，结果限于32位带符号范围（溢出时设Q标志）。 | ARMv6+ (ARMv7-A) |
| `MUL`  | Multiple | 32位寄存器乘法，结果低32位 | `MUL R0, R1, R2` | 将 `R1 * R2` 的低32位结果存入 `R0`。 | ARMv4+ |
| `MLA`  | Multiple-LinearAdd | `Rn*Rm + Ra` 乘加，结果低32位 | `MLA R0, R1, R2, R3` | 将 `R1 * R2 + R3` 的低32位结果存入 `R0`。 | ARMv4+ |
| `SDIV` | Symboled Division | 两寄存器带符号整数除法 | `SDIV R0, R1, R2` | 将 `R1 (signed) / R2 (signed)` 的结果存入 `R0`（ARMv7+ 新增）。 | ARMv7+ (A32) |
| `UDIV` | Unsymboled Division | 两寄存器无符号整数除法 | `UDIV R0, R1, R2`    | 将 `R1 / R2` 的无符号商存入 `R0`（ARMv7+ 新增）。 | ARMv7+ (A32) |

### 2.3 跳转类
| 指令 | 速记 | 用途 | 示例代码 | 示例释义 | 架构版本 |
| -------- | --------- | ------- | --- | ----- | ------- |
| `B` | 跳转 | 无条件跳转至标签 | `B loop` | 跳转到标签 `loop` 处继续执行，无条件分支。 | ARMv4+  |
| `B.cond` | 条件跳转 | 按条件跳转至标签 | `BNE label` | 如果上一次结果**不等**（Z=0），则跳转到 `label`；否则继续。 | ARMv4+  |
| `BL` | 带链接跳转（调用） | 调用子程序（保存返回地址） | `BL func` | 调用函数 `func`：将下一条指令地址保存在 `LR`，然后跳转执行 `func`。 | ARMv4+  |
| `BLR` | 带链接跳转寄存器  | 跳转至寄存器指定地址并调用子程序 | `BLR X1` | 跳转到寄存器 `X1` 指向的地址并执行，将返回地址保存在 `LR`（A64 新增）。 | ARMv8-A |
| `BR` | 寄存器跳转 | 无条件跳转至寄存器指定地址 | `BR X0` | 跳转到寄存器 `X0` 指向的地址（无链接），用于 A64 的间接跳转。 | ARMv8-A |

跳转类地址将直接改变寄存器`PC`。


## 9. ABI

- R0~R3由主程序保存。
- R4~R11保存局部变量，此时有别名v1~v8。保存之前必须push/pop。
- 如果目标包含了外部调用用，则必须让堆栈满足`pack(8)`

