## 注意：

如果要理解什么是“栈帧”，你需要模仿计算机的行为：
- 读取指令，从内存取出下一条要执行的机器指令。
    - 读取指令的位置在`r15`，即`pc`。（在32位机器里）每执行完一条指令，该寄存器的值会+4。
    - ARM架构中，（在32位机器里）指令的长度为32位，即4个byte（`char`）。
    - ARM架构中，保存栈的指针是`r13`即`sp`，函数执行完毕后的返回地址位于`r14`。
- 执行指令
    - 更新寄存器的值，或：
    - 更新内存的值

## 什么是栈帧？

接下来的一长段内，会有一系列模拟CPU的行为。
- 对于寄存器状态，和上个状态相比，变化的值将被高亮显示。
- 对于程序和函数，在上个状态中被使用的指令将被高亮显示。
- 只要过了这个东西，就可以理解什么是“栈帧”。

### 状态0（从这里开始看）

主程序区域（main）：
- 0x01000000 | ldr r13, =0x40000000       `<-r15` @ 设置栈顶指针 SP = 0x40000000
- 0x01000004 | mov r1, #0x13              @ 把立即数 0x13 装入 r1
- 0x01000008 | bl  func1                  @ 跳转到函数 func1，并把返回地址保存到 r14
- 0x0100000C | ldr r2, [r13]              @ （调用结束后）读栈内容
- 0x01000010 | add r4, r1, r2             @ 用 r1 和 r2 做加法
- 0x01000014 | ...                        @ 其他指令（暂不涉及）

被调用函数区域（func1）：
- 0x01234567 | push {r4, lr}              @ 保存 r4 和 lr，建立栈帧
- 0x0123456B | add  r4, r1, #1            @ r4 = r1 + 1 （举例，做点运算）
- 0x0123456F | pop  {r4, pc}              @ 恢复寄存器并返回

寄存器状态
- r1=0x00000000 r2=0x00000000 r3=0x00000000 r4=0xDEADBEEF
- ... ... @ 中间的寄存器暂时用不到
- r13=0x00000000 r14=0x00000000 r15=0x01000000

栈帧情况
- 不可用

### 状态1

主程序区域（main）：
- `0x01000000 | ldr r13, =0x40000000`       @ 设置栈顶指针 SP = 0x40000000
- 0x01000004 | mov r1, #0x13              `<-r15` @ 把立即数 0x13 装入 r1
- 0x01000008 | bl  func1                  @ 跳转到函数 func1，并把返回地址保存到 r14
- 0x0100000C | ldr r2, [r13]              @ （调用结束后）读栈内容
- 0x01000010 | add r4, r1, r2             @ 用 r1 和 r2 做加法
- 0x01000014 | ...                        @ 其他指令（暂不涉及）

被调用函数区域（func1）：
- 0x01234567 | push {r4, lr}              @ 保存 r4 和 lr，建立栈帧
- 0x0123456B | add  r4, r1, #1            @ r4 = r1 + 1 （举例，做点运算）
- 0x0123456F | pop  {r4, pc}              @ 恢复寄存器并返回

寄存器状态
- r1=0x00000000 r2=0x00000000 r3=0x00000000 r4=0xDEADBEEF
- ... ... @ 中间的寄存器暂时用不到
- r13=`0x40000000` r14=0x00000000 r15=`0x01000004`

栈帧情况
- 0x40000000 | 0        `<-r13`
- 0x3FFFFFFC | 0
- 0x3FFFFFF8 | 0
- 0x3FFFFFF4 | 0

### 状态2

主程序区域（main）：
- 0x01000000 | ldr r13, =0x40000000       @ 设置栈顶指针 SP = 0x40000000
- `0x01000004 | mov r1, #0x13`              @ 把立即数 0x13 装入 r1
- 0x01000008 | bl  func1                  `<-r15` @ 跳转到函数 func1，并把返回地址保存到 r14
- 0x0100000C | ldr r2, [r13]              @ （调用结束后）读栈内容
- 0x01000010 | add r4, r1, r2             @ 用 r1 和 r2 做加法
- 0x01000014 | ...                        @ 其他指令（暂不涉及）

被调用函数区域（func1）：
- 0x01234567 | push {r4, lr}              @ 保存 r4 和 lr，建立栈帧
- 0x0123456B | add  r4, r1, #1            @ r4 = r1 + 1 （举例，做点运算）
- 0x0123456F | pop  {r4, pc}              @ 恢复寄存器并返回

寄存器状态
- r1=`0x00000013` r2=0x00000000 r3=0x00000000 r4=0xDEADBEEF
- ... ... @ 中间的寄存器暂时用不到
- r13=0x40000000 r14=0x00000000 r15=`0x01000008`

栈帧情况
- 0x40000000 | 0        `<-r13`
- 0x3FFFFFFC | 0
- 0x3FFFFFF8 | 0
- 0x3FFFFFF4 | 0

### 状态3

主程序区域（main）：
- 0x01000000 | ldr r13, =0x40000000       @ 设置栈顶指针 SP = 0x40000000
- 0x01000004 | mov r1, #0x13              @ 把立即数 0x13 装入 r1
- `0x01000008 | bl  func1`                  @ 跳转到函数 func1，并把返回地址保存到 r14
- 0x0100000C | ldr r2, [r13]              @ （调用结束后）读栈内容
- 0x01000010 | add r4, r1, r2             @ 用 r1 和 r2 做加法
- 0x01000014 | ...                        @ 其他指令（暂不涉及）

被调用函数区域（func1）：
- 0x01234567 | push {r4, lr}              `<-r15` @ 保存 r4 和 lr，建立栈帧，等价于：`stmdb sp!, {r4, lr}`
- 0x0123456B | add  r4, r1, #1            @ r4 = r1 + 1 （举例，做点运算）
- 0x0123456F | pop  {r4, pc}              @ 恢复寄存器并返回

寄存器状态
- r1=0x00000013 r2=0x00000000 r3=0x00000000 r4=0xDEADBEEF
- ... ... @ 中间的寄存器暂时用不到
- r13=0x40000000 r14=`0x1000000C` r15=`0x01234567`

栈帧情况
- 0x40000000 | 0       `<-r13`
- 0x3FFFFFFC | 0
- 0x3FFFFFF8 | 0
- 0x3FFFFFF4 | 0

> 注：`stmdb sp!, {r4, lr}`，意为在`sp`的地址上先后写入`r4`和`lr`的值。

### 状态4

主程序区域（main）：
- 0x01000000 | ldr r13, =0x40000000       @ 设置栈顶指针 SP = 0x40000000
- 0x01000004 | mov r1, #0x13              @ 把立即数 0x13 装入 r1
- 0x01000008 | bl  func1                  @ 跳转到函数 func1，并把返回地址保存到 r14
- 0x0100000C | ldr r2, [r13]              @ （调用结束后）读栈内容
- 0x01000010 | add r4, r1, r2             @ 用 r1 和 r2 做加法
- 0x01000014 | ...                        @ 其他指令（暂不涉及）

被调用函数区域（func1）：
- `0x01234567 | push {r4, lr}`              @ 保存 r4 和 lr，建立栈帧
- 0x0123456B | add  r4, r1, #1            `<-r15` @ r4 = r1 + 1 （举例，做点运算）
- 0x0123456F | pop  {r4, pc}              @ 恢复寄存器并返回

寄存器状态
- r1=0x00000013 r2=0x00000000 r3=0x00000000 r4=0xDEADBEEF
- ... ... @ 中间的寄存器暂时用不到
- r13=`0x3FFFFFF8` r14=0x1000000C r15=`0x0123456B`

栈帧情况
- 0x40000000 | 0       
- 0x3FFFFFFC | 0x0100000C          @ 保存的返回地址
- 0x3FFFFFF8 | 0xDEADBEEF          `<-r13` @ 保存的r4
- 0x3FFFFFF4 | 0                   

> 注意：此时进入函数`func1`，栈帧的作用从现在将开始。

### 状态5

主程序区域（main）：
- 0x01000000 | ldr r13, =0x40000000       @ 设置栈顶指针 SP = 0x40000000
- 0x01000004 | mov r1, #0x13              @ 把立即数 0x13 装入 r1
- 0x01000008 | bl  func1                  @ 跳转到函数 func1，并把返回地址保存到 r14
- 0x0100000C | ldr r2, [r13]              @ （调用结束后）读栈内容
- 0x01000010 | add r4, r1, r2             @ 用 r1 和 r2 做加法
- 0x01000014 | ...                        @ 其他指令（暂不涉及）

被调用函数区域（func1）：
- 0x01234567 | push {r4, lr}              @ 保存 r4 和 lr，建立栈帧
- `0x0123456B | add  r4, r1, #1`            @ r4 = r1 + 1 （举例，做点运算）
- 0x0123456F | pop  {r4, pc}              `<-r15` @ 恢复寄存器并返回

寄存器状态
- r1=0x00000013 r2=0x00000000 r3=0x00000000 r4=`0x00000014`
- ... ... @ 中间的寄存器暂时用不到
- r13=0x3FFFFFF8 r14=0x1000000C r15=`0x0123456B`

栈帧情况
- 0x40000000 | 0       
- 0x3FFFFFFC | 0x0100000C
- 0x3FFFFFF8 | 0xDEADBEEF       `<-r13`
- 0x3FFFFFF4 | 0                   

> 注意：这里`r4`改变了，栈帧的作用马上就要体现了！让大局逆转吧！

### 状态6

主程序区域（main）：
- 0x01000000 | ldr r13, =0x40000000       @ 设置栈顶指针 SP = 0x40000000
- 0x01000004 | mov r1, #0x13              @ 把立即数 0x13 装入 r1
- 0x01000008 | bl  func1                  @ 跳转到函数 func1，并把返回地址保存到 r14
- 0x0100000C | ldr r2, [r13]              `<-r15` @ （调用结束后）读栈内容
- 0x01000010 | add r4, r1, r2             @ 用 r1 和 r2 做加法
- 0x01000014 | ...                        @ 其他指令（暂不涉及）

被调用函数区域（func1）：
- 0x01234567 | push {r4, lr}              @ 保存 r4 和 lr，建立栈帧
- 0x0123456B | add  r4, r1, #1            @ r4 = r1 + 1 （举例，做点运算）
- `0x0123456F | pop  {r4, pc}`              @ 恢复寄存器并返回

寄存器状态
- r1=0x00000013 r2=0x00000000 r3=0x00000000 r4=`0xDEADBEEF`
- ... ... @ 中间的寄存器暂时用不到
- r13=`0x40000000` r14=0x1000000C r15=`0x1000000C`

栈帧情况
- 0x40000000 | 0            `<-r13`
- 0x3FFFFFFC | 0x0100000C
- 0x3FFFFFF8 | 0xDEADBEEF
- 0x3FFFFFF4 | 0                   

> 注意：这里将`r4`返回了0xDEADBEEF。

### 状态7

主程序区域（main）：
- 0x01000000 | ldr r13, =0x40000000       @ 设置栈顶指针 SP = 0x40000000
- 0x01000004 | mov r1, #0x13              @ 把立即数 0x13 装入 r1
- 0x01000008 | bl  func1                  @ 跳转到函数 func1，并把返回地址保存到 r14
- `0x0100000C | ldr r2, [r13]`              @ （调用结束后）读栈内容
- 0x01000010 | add r4, r1, r2             `<-r15` @ 用 r1 和 r2 做加法
- 0x01000014 | ...                        @ 其他指令（暂不涉及）

被调用函数区域（func1）：
- 0x01234567 | push {r4, lr}              @ 保存 r4 和 lr，建立栈帧
- 0x0123456B | add  r4, r1, #1            @ r4 = r1 + 1 （举例，做点运算）
- 0x0123456F | pop  {r4, pc}              @ 恢复寄存器并返回

寄存器状态
- r1=0x00000013 r2=`0x00000000` r3=0x00000000 r4=0xDEADBEEF
- ... ... @ 中间的寄存器暂时用不到
- r13=`0x40000000` r14=0x1000000C r15=`0x1000000C`

栈帧情况
- 0x40000000 | 0            `<-r13`
- 0x3FFFFFFC | 0x0100000C
- 0x3FFFFFF8 | 0xDEADBEEF
- 0x3FFFFFF4 | 0   

### 总结

从进入函数开始，某个指令让`r4`的值被编辑。但在状态6，即退出该函数时，`r4`的值被恢复。
- 栈帧的作用是：**临时保存一个或多个寄存器的值（状态），使其在函数执行期间，不被影响**。

